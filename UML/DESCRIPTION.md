    ## SShell
Класс, который запускает интерпретатор. Стартует процесс считывания выражений, их парсинг и исполнение.

Поля:
- `cmdEnv: List<CommandEnvironment>` – в них будут пытаться найти команду для выполнения.
- `varEnv: VariableEnvironment` – в нем хранятся все переменные окружения
- `userInteraction: UserInteraction` – через него осуществляется чтение текста выражений
- `runner: Runner` – запускает исполнение выражения
- `parser: Parser` – парсит выражения
- `io: IO` – содержит различные потоки для stdin, stdout, stderr и т.п.

Методы:
- `start()` – запускает интерпретатор. В цикле происходит чтение выражения, его парсинг
и исполнение.

## IO
Содержит различные потоки для stdin, stdout, stderr и т.п.


## CommandEnvironmnet
Базовый интерфейс для поиска команды по ее строковому представлению.

Методы:
- `getCommand(String): Optional<Command>` – принимает на вход имя команды, возвращает ее, если данное окружение знает такую команду

## BuiltinCommandEnvironment
Имплементация интерфейса `CommandEnvironmnet`. Хранит внутри себя базовые команды, которые мы делаем в баше (wc, echo и т д). По сути словарь из имени команды в представителя класса команды.

Методы:
- `register(String, Command)` – добавляет новую команду.

## ExternalCommandEnvironment
Имплементация интерфейса CommandEnvironmnet. Необходим для использования неизвестных команд для нашего интерпретатора. Хранит внутри себя список путей, по которым он может найти необходимую команду. Также умеет искать команды, если передается абсолютный путь до команды (например, `/bin/ls`) или по относительному пути от текущей директории

Методы:
- `addPath(String)` – добавляет новый путь для поиска команд (по сути аналог переменной окружения PATH).

## Command
Базовый интерфейс для всех команд.

Методы:
- `execute(env: Map<String, String>, List<String>, IO)` – вычисляет результат на основании значений аргументов, переданных в листе и на основании стрима входных данных (например, в качестве стрима может выступать межпроцессный канал, который находится между двумя процессами при запуске нашего башевого пайпа). Первый аргумент для метода нужен для запуска внешних команд, потому что они могут использовать переменные окружения.

## Встроенные команды 
`Echo`, `ExitCommand`, `Cat`, `WordCount`, `PrintWorkingDirectory`, `Cd`, `Ls` – имплементация интерфейса command, которые на основании аргументов и потока ввода выводят в поток вывода результат выполнения, который аналогичен башевому варианту.

## ExternalCommand
имплементация интерфейса command, класс, который дополнительно в конструкторе получает путь до внешнего исполняемого файла и запускает его с помощью Process

## UserInteraction
Класс, который прямо взаимодействует с пользователем.

Поля:
- `input: InputStream` – поток, куда пользователь печатает свои команды
- `output: OutputStream` – поток, куда выводится взаимодействие с пользователем: приветствие, предложение написать очередную команду (>>>)
Методы:
- `read(): String` – читает строку, введенную пользователем

## Runner
Класс, необходимый для запуска пайпа или одиночной команды.

Поля:
- `cmdEnv: List<CommandEnvironment>` – в них будут пытаться найти команды для выполнения.
- `varEnv: VariableEnvironment` – в нем хранятся все переменные окружения.

Методы:
- `run(Statement, IO)` – запуск исполнения выражения.

## Variable Environment
Класс, содержащей в себя переменные окружения с вычисленным значением и текущую рабочую директорию.

Поля:
- `parent: Optional<VariableEnvironment>` – родительское окружение, в котором будет искаться переменная, если не найдется в текущем (в пайпе могут создаваться переменные, сначала переменные ищутся в них, потом в глобальном scope)
- `nameToValue: Map<String, String>` – словарь со значениями переменных
- `workingDirectory: Path` - текущая рабочая директория

Методы:
- `get(String): String` – получение значения переменной.
- `set(String, String)` – задание значения переменной.
- `fork(): VariableEnvironment` – создает дочернее окружение, с родителем – текущим окружением.
- `getWorkingDirectory(): Path` - возвращает текущую рабочую директорию.
- `resetWorkingDirectory()` - устаавливет первоначальную текущую рабочую директорию.
- `changeWorkingDirectory(path: Path, onError: (String) -> Unit): Path?` - меняет текущую рабочую директорию в зависимости от пути, если не существует такого пути, то возращает `null`.

## Parser
Класс, который разбирает команду в синтаксическое дерево и делает подстановку переменных.

Методы:
- `parse(String): PreStatement` – разбирает строку в синтаксическое дерево и оставляет подстановки вершинами
- `subst(PreStatement, VariableEnvironment)` – подставляет значения переменных и объединяет соседние строки, возвращая команду и её аргументы или присвоение

## Prestatement
data class, содержащий дерево разбора без подставленных переменных

## Statement
data class, содержащий лист из команд в пайпе

## Task
sealed interface того, какие команды можно исполнить

## Assignement
data class, содержащий информацию о команде присвоения значения в переменную

## CommandRun
data class, содержащий информацию о вызове внешней или встроенной команды

## CommandResult
interface, для результатов команды

## Exit
имплементация `CommandResult` для специальной команды `Exit`

##ReturnCode
имплементация `CommandResult`, которая внутри себя содержит код возврата

## Описание работы
Вначале происходит конструирование `SShell`’a. Для этого вначале мы регистрируем в `BuiltinCommandEnvironment`
встроенные функции (echo, wc и т д). Далее создается `ExternalCommandEnvironment`, в который добавляются базовые пути
для поиска внешних ресурсов (/usr/local/sbin, /usr/local/bin, /usr/sbin, /usr/bin, /sbin, /bin)
Затем мы создаём пустой `VariableEnvironment`, поскольку в данных момент у нас нет переменных. А также `UserInteraction`,
который направляется при отсутствии дополнительных аргументов в `system.in` и `system.out`. Создается `IO`, который
отвечает за потоки вывода и ввода результатов команд (то есть ввод пользователя и вывод команд, а также ресурсы для
них(=команд) могут быть разнесены). Дальше создается `Runner`, в который передаются окружения для переменных и команд.
Создается и сохраняется `Parser`. После всего этого происходит запуск `SShell`’a.

Дальше последовательно с помощью `UserInteraction` выводится приветствие для пользователя написать строчку (`>>>`). С
помощью него же считывается строка, которая в дальнейшем передается в Parser::parse, который разбирает её с помощью
парсера, сгенерированного при помощи библиотеки **antlr** (по грамматике в этом репозитории). Затем мы берем дерево по
одному `Statement`’у и передаём вместе с  `VariableEnvironment` в функцию `Parser::subst`. В дереве узлы с подстановкой
переменных заменяются на их значение и разделяются по пробелам. Потом соседние непробельные токены соединяются вместе.
Затем,
- если код распарсился как запуск команды, то из списка строк, выделяется первая – название команды и последующие, её 
аргументы и записывается в `CommandRun`
- если код распарсился как присвоение в переменную, то название переменной и новое значение, записываются в
`Assignement`

Дальше происходит запуск пайпа или одиночной команды внутри `Runner`, для этого передается `IO`, который служит
“крайними источниками ввода-вывода”. После этого мы берем каждый из `Task` внутри `Statement`, и последовательно 
исполняем каждый из них. Между ними мы создаем output и input стримы (один и тот же стрим для одного процесса является
входным, а для другого выходным). Входом для первого является вход `IO`, выходом для последнего является выход `IO`.
При этом если `Task` является на самом деле CommandRun, то происходит поиск команды с помощью существующего окружения команд (идем по массиву
`CommandEnvironment` и смотрим на результат операции `getCommand`, после запускаем команду), если же `Assignment`, то
изменяем значения в `VariableEnvironment`, записывая туда строчку. Также в классе `IO` есть отдельное поле для потока ошибок.
В него мы логгируем все некорректные команды/ошибки для каждого из `Task`. Отдельно стоит отметить, что если `Task` является
командой выхода `Exit`, то все последующие вычисления исполняться не будут и программа завершается. Так же результатом каждого из `execute`
является какой-то код возврата. Если он не является успешным, то текущий `pipe` останавливается, но мы все еще можем вводить новые команды.

После этого мы повторяем эти же действия для всех `Statement`.

После завершения для всех `Statement`, которые были разделены `;` мы снова выводим приветствие для пользователя.

